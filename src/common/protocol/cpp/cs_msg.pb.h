// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cs_msg.proto

#ifndef PROTOBUF_cs_5fmsg_2eproto__INCLUDED
#define PROTOBUF_cs_5fmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "cs_role.pb.h"
#include "cs_reg.pb.h"
#include "cs_notify.pb.h"
// @@protoc_insertion_point(includes)

namespace ProtoCs {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cs_5fmsg_2eproto();
void protobuf_AssignDesc_cs_5fmsg_2eproto();
void protobuf_ShutdownFile_cs_5fmsg_2eproto();

class Head;
class Msg;

// ===================================================================

class Head : public ::google::protobuf::Message {
 public:
  Head();
  virtual ~Head();

  Head(const Head& from);

  inline Head& operator=(const Head& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Head& default_instance();

  void Swap(Head* other);

  // implements Message ----------------------------------------------

  Head* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Head& from);
  void MergeFrom(const Head& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);

  // optional int32 ret = 2;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional uint64 seq = 3;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 3;
  inline ::google::protobuf::uint64 seq() const;
  inline void set_seq(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ProtoCs.Head)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::uint64 seq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cs_5fmsg_2eproto();
  friend void protobuf_AssignDesc_cs_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_cs_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Head* default_instance_;
};
// -------------------------------------------------------------------

class Msg : public ::google::protobuf::Message {
 public:
  Msg();
  virtual ~Msg();

  Msg(const Msg& from);

  inline Msg& operator=(const Msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg& default_instance();

  void Swap(Msg* other);

  // implements Message ----------------------------------------------

  Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg& from);
  void MergeFrom(const Msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ProtoCs.Head head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::ProtoCs::Head& head() const;
  inline ::ProtoCs::Head* mutable_head();
  inline ::ProtoCs::Head* release_head();
  inline void set_allocated_head(::ProtoCs::Head* head);

  // optional .ProtoCs.LoginReq login_req = 11;
  inline bool has_login_req() const;
  inline void clear_login_req();
  static const int kLoginReqFieldNumber = 11;
  inline const ::ProtoCs::LoginReq& login_req() const;
  inline ::ProtoCs::LoginReq* mutable_login_req();
  inline ::ProtoCs::LoginReq* release_login_req();
  inline void set_allocated_login_req(::ProtoCs::LoginReq* login_req);

  // optional .ProtoCs.LoginRes login_res = 12;
  inline bool has_login_res() const;
  inline void clear_login_res();
  static const int kLoginResFieldNumber = 12;
  inline const ::ProtoCs::LoginRes& login_res() const;
  inline ::ProtoCs::LoginRes* mutable_login_res();
  inline ::ProtoCs::LoginRes* release_login_res();
  inline void set_allocated_login_res(::ProtoCs::LoginRes* login_res);

  // optional .ProtoCs.QuickRegReq quick_reg_req = 13;
  inline bool has_quick_reg_req() const;
  inline void clear_quick_reg_req();
  static const int kQuickRegReqFieldNumber = 13;
  inline const ::ProtoCs::QuickRegReq& quick_reg_req() const;
  inline ::ProtoCs::QuickRegReq* mutable_quick_reg_req();
  inline ::ProtoCs::QuickRegReq* release_quick_reg_req();
  inline void set_allocated_quick_reg_req(::ProtoCs::QuickRegReq* quick_reg_req);

  // optional .ProtoCs.QuickRegRes quick_reg_res = 14;
  inline bool has_quick_reg_res() const;
  inline void clear_quick_reg_res();
  static const int kQuickRegResFieldNumber = 14;
  inline const ::ProtoCs::QuickRegRes& quick_reg_res() const;
  inline ::ProtoCs::QuickRegRes* mutable_quick_reg_res();
  inline ::ProtoCs::QuickRegRes* release_quick_reg_res();
  inline void set_allocated_quick_reg_res(::ProtoCs::QuickRegRes* quick_reg_res);

  // optional .ProtoCs.NormalRegReq normal_reg_req = 15;
  inline bool has_normal_reg_req() const;
  inline void clear_normal_reg_req();
  static const int kNormalRegReqFieldNumber = 15;
  inline const ::ProtoCs::NormalRegReq& normal_reg_req() const;
  inline ::ProtoCs::NormalRegReq* mutable_normal_reg_req();
  inline ::ProtoCs::NormalRegReq* release_normal_reg_req();
  inline void set_allocated_normal_reg_req(::ProtoCs::NormalRegReq* normal_reg_req);

  // optional .ProtoCs.NormalRegRes normal_reg_res = 16;
  inline bool has_normal_reg_res() const;
  inline void clear_normal_reg_res();
  static const int kNormalRegResFieldNumber = 16;
  inline const ::ProtoCs::NormalRegRes& normal_reg_res() const;
  inline ::ProtoCs::NormalRegRes* mutable_normal_reg_res();
  inline ::ProtoCs::NormalRegRes* release_normal_reg_res();
  inline void set_allocated_normal_reg_res(::ProtoCs::NormalRegRes* normal_reg_res);

  // optional .ProtoCs.BindAccountReq bind_account_req = 17;
  inline bool has_bind_account_req() const;
  inline void clear_bind_account_req();
  static const int kBindAccountReqFieldNumber = 17;
  inline const ::ProtoCs::BindAccountReq& bind_account_req() const;
  inline ::ProtoCs::BindAccountReq* mutable_bind_account_req();
  inline ::ProtoCs::BindAccountReq* release_bind_account_req();
  inline void set_allocated_bind_account_req(::ProtoCs::BindAccountReq* bind_account_req);

  // optional .ProtoCs.BindAccountRes bind_account_res = 18;
  inline bool has_bind_account_res() const;
  inline void clear_bind_account_res();
  static const int kBindAccountResFieldNumber = 18;
  inline const ::ProtoCs::BindAccountRes& bind_account_res() const;
  inline ::ProtoCs::BindAccountRes* mutable_bind_account_res();
  inline ::ProtoCs::BindAccountRes* release_bind_account_res();
  inline void set_allocated_bind_account_res(::ProtoCs::BindAccountRes* bind_account_res);

  // optional .ProtoCs.EditPasswordReq edit_password_req = 19;
  inline bool has_edit_password_req() const;
  inline void clear_edit_password_req();
  static const int kEditPasswordReqFieldNumber = 19;
  inline const ::ProtoCs::EditPasswordReq& edit_password_req() const;
  inline ::ProtoCs::EditPasswordReq* mutable_edit_password_req();
  inline ::ProtoCs::EditPasswordReq* release_edit_password_req();
  inline void set_allocated_edit_password_req(::ProtoCs::EditPasswordReq* edit_password_req);

  // optional .ProtoCs.EditPasswordRes edit_password_res = 20;
  inline bool has_edit_password_res() const;
  inline void clear_edit_password_res();
  static const int kEditPasswordResFieldNumber = 20;
  inline const ::ProtoCs::EditPasswordRes& edit_password_res() const;
  inline ::ProtoCs::EditPasswordRes* mutable_edit_password_res();
  inline ::ProtoCs::EditPasswordRes* release_edit_password_res();
  inline void set_allocated_edit_password_res(::ProtoCs::EditPasswordRes* edit_password_res);

  // optional .ProtoCs.RoleInfoNtf role_info_ntf = 6001;
  inline bool has_role_info_ntf() const;
  inline void clear_role_info_ntf();
  static const int kRoleInfoNtfFieldNumber = 6001;
  inline const ::ProtoCs::RoleInfoNtf& role_info_ntf() const;
  inline ::ProtoCs::RoleInfoNtf* mutable_role_info_ntf();
  inline ::ProtoCs::RoleInfoNtf* release_role_info_ntf();
  inline void set_allocated_role_info_ntf(::ProtoCs::RoleInfoNtf* role_info_ntf);

  // optional .ProtoCs.CityListNtf city_list_ntf = 6002;
  inline bool has_city_list_ntf() const;
  inline void clear_city_list_ntf();
  static const int kCityListNtfFieldNumber = 6002;
  inline const ::ProtoCs::CityListNtf& city_list_ntf() const;
  inline ::ProtoCs::CityListNtf* mutable_city_list_ntf();
  inline ::ProtoCs::CityListNtf* release_city_list_ntf();
  inline void set_allocated_city_list_ntf(::ProtoCs::CityListNtf* city_list_ntf);

  // optional .ProtoCs.ServerKickOffNtf server_kick_off_ntf = 6003;
  inline bool has_server_kick_off_ntf() const;
  inline void clear_server_kick_off_ntf();
  static const int kServerKickOffNtfFieldNumber = 6003;
  inline const ::ProtoCs::ServerKickOffNtf& server_kick_off_ntf() const;
  inline ::ProtoCs::ServerKickOffNtf* mutable_server_kick_off_ntf();
  inline ::ProtoCs::ServerKickOffNtf* release_server_kick_off_ntf();
  inline void set_allocated_server_kick_off_ntf(::ProtoCs::ServerKickOffNtf* server_kick_off_ntf);

  // @@protoc_insertion_point(class_scope:ProtoCs.Msg)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_login_req();
  inline void clear_has_login_req();
  inline void set_has_login_res();
  inline void clear_has_login_res();
  inline void set_has_quick_reg_req();
  inline void clear_has_quick_reg_req();
  inline void set_has_quick_reg_res();
  inline void clear_has_quick_reg_res();
  inline void set_has_normal_reg_req();
  inline void clear_has_normal_reg_req();
  inline void set_has_normal_reg_res();
  inline void clear_has_normal_reg_res();
  inline void set_has_bind_account_req();
  inline void clear_has_bind_account_req();
  inline void set_has_bind_account_res();
  inline void clear_has_bind_account_res();
  inline void set_has_edit_password_req();
  inline void clear_has_edit_password_req();
  inline void set_has_edit_password_res();
  inline void clear_has_edit_password_res();
  inline void set_has_role_info_ntf();
  inline void clear_has_role_info_ntf();
  inline void set_has_city_list_ntf();
  inline void clear_has_city_list_ntf();
  inline void set_has_server_kick_off_ntf();
  inline void clear_has_server_kick_off_ntf();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoCs::Head* head_;
  ::ProtoCs::LoginReq* login_req_;
  ::ProtoCs::LoginRes* login_res_;
  ::ProtoCs::QuickRegReq* quick_reg_req_;
  ::ProtoCs::QuickRegRes* quick_reg_res_;
  ::ProtoCs::NormalRegReq* normal_reg_req_;
  ::ProtoCs::NormalRegRes* normal_reg_res_;
  ::ProtoCs::BindAccountReq* bind_account_req_;
  ::ProtoCs::BindAccountRes* bind_account_res_;
  ::ProtoCs::EditPasswordReq* edit_password_req_;
  ::ProtoCs::EditPasswordRes* edit_password_res_;
  ::ProtoCs::RoleInfoNtf* role_info_ntf_;
  ::ProtoCs::CityListNtf* city_list_ntf_;
  ::ProtoCs::ServerKickOffNtf* server_kick_off_ntf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_cs_5fmsg_2eproto();
  friend void protobuf_AssignDesc_cs_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_cs_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Msg* default_instance_;
};
// ===================================================================


// ===================================================================

// Head

// optional int32 cmd = 1;
inline bool Head::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Head::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Head::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Head::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 Head::cmd() const {
  return cmd_;
}
inline void Head::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 ret = 2;
inline bool Head::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Head::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Head::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Head::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 Head::ret() const {
  return ret_;
}
inline void Head::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional uint64 seq = 3;
inline bool Head::has_seq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Head::set_has_seq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Head::clear_has_seq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Head::clear_seq() {
  seq_ = GOOGLE_ULONGLONG(0);
  clear_has_seq();
}
inline ::google::protobuf::uint64 Head::seq() const {
  return seq_;
}
inline void Head::set_seq(::google::protobuf::uint64 value) {
  set_has_seq();
  seq_ = value;
}

// -------------------------------------------------------------------

// Msg

// optional .ProtoCs.Head head = 1;
inline bool Msg::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg::clear_head() {
  if (head_ != NULL) head_->::ProtoCs::Head::Clear();
  clear_has_head();
}
inline const ::ProtoCs::Head& Msg::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::ProtoCs::Head* Msg::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::ProtoCs::Head;
  return head_;
}
inline ::ProtoCs::Head* Msg::release_head() {
  clear_has_head();
  ::ProtoCs::Head* temp = head_;
  head_ = NULL;
  return temp;
}
inline void Msg::set_allocated_head(::ProtoCs::Head* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// optional .ProtoCs.LoginReq login_req = 11;
inline bool Msg::has_login_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg::set_has_login_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg::clear_has_login_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg::clear_login_req() {
  if (login_req_ != NULL) login_req_->::ProtoCs::LoginReq::Clear();
  clear_has_login_req();
}
inline const ::ProtoCs::LoginReq& Msg::login_req() const {
  return login_req_ != NULL ? *login_req_ : *default_instance_->login_req_;
}
inline ::ProtoCs::LoginReq* Msg::mutable_login_req() {
  set_has_login_req();
  if (login_req_ == NULL) login_req_ = new ::ProtoCs::LoginReq;
  return login_req_;
}
inline ::ProtoCs::LoginReq* Msg::release_login_req() {
  clear_has_login_req();
  ::ProtoCs::LoginReq* temp = login_req_;
  login_req_ = NULL;
  return temp;
}
inline void Msg::set_allocated_login_req(::ProtoCs::LoginReq* login_req) {
  delete login_req_;
  login_req_ = login_req;
  if (login_req) {
    set_has_login_req();
  } else {
    clear_has_login_req();
  }
}

// optional .ProtoCs.LoginRes login_res = 12;
inline bool Msg::has_login_res() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg::set_has_login_res() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg::clear_has_login_res() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg::clear_login_res() {
  if (login_res_ != NULL) login_res_->::ProtoCs::LoginRes::Clear();
  clear_has_login_res();
}
inline const ::ProtoCs::LoginRes& Msg::login_res() const {
  return login_res_ != NULL ? *login_res_ : *default_instance_->login_res_;
}
inline ::ProtoCs::LoginRes* Msg::mutable_login_res() {
  set_has_login_res();
  if (login_res_ == NULL) login_res_ = new ::ProtoCs::LoginRes;
  return login_res_;
}
inline ::ProtoCs::LoginRes* Msg::release_login_res() {
  clear_has_login_res();
  ::ProtoCs::LoginRes* temp = login_res_;
  login_res_ = NULL;
  return temp;
}
inline void Msg::set_allocated_login_res(::ProtoCs::LoginRes* login_res) {
  delete login_res_;
  login_res_ = login_res;
  if (login_res) {
    set_has_login_res();
  } else {
    clear_has_login_res();
  }
}

// optional .ProtoCs.QuickRegReq quick_reg_req = 13;
inline bool Msg::has_quick_reg_req() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Msg::set_has_quick_reg_req() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Msg::clear_has_quick_reg_req() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Msg::clear_quick_reg_req() {
  if (quick_reg_req_ != NULL) quick_reg_req_->::ProtoCs::QuickRegReq::Clear();
  clear_has_quick_reg_req();
}
inline const ::ProtoCs::QuickRegReq& Msg::quick_reg_req() const {
  return quick_reg_req_ != NULL ? *quick_reg_req_ : *default_instance_->quick_reg_req_;
}
inline ::ProtoCs::QuickRegReq* Msg::mutable_quick_reg_req() {
  set_has_quick_reg_req();
  if (quick_reg_req_ == NULL) quick_reg_req_ = new ::ProtoCs::QuickRegReq;
  return quick_reg_req_;
}
inline ::ProtoCs::QuickRegReq* Msg::release_quick_reg_req() {
  clear_has_quick_reg_req();
  ::ProtoCs::QuickRegReq* temp = quick_reg_req_;
  quick_reg_req_ = NULL;
  return temp;
}
inline void Msg::set_allocated_quick_reg_req(::ProtoCs::QuickRegReq* quick_reg_req) {
  delete quick_reg_req_;
  quick_reg_req_ = quick_reg_req;
  if (quick_reg_req) {
    set_has_quick_reg_req();
  } else {
    clear_has_quick_reg_req();
  }
}

// optional .ProtoCs.QuickRegRes quick_reg_res = 14;
inline bool Msg::has_quick_reg_res() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Msg::set_has_quick_reg_res() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Msg::clear_has_quick_reg_res() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Msg::clear_quick_reg_res() {
  if (quick_reg_res_ != NULL) quick_reg_res_->::ProtoCs::QuickRegRes::Clear();
  clear_has_quick_reg_res();
}
inline const ::ProtoCs::QuickRegRes& Msg::quick_reg_res() const {
  return quick_reg_res_ != NULL ? *quick_reg_res_ : *default_instance_->quick_reg_res_;
}
inline ::ProtoCs::QuickRegRes* Msg::mutable_quick_reg_res() {
  set_has_quick_reg_res();
  if (quick_reg_res_ == NULL) quick_reg_res_ = new ::ProtoCs::QuickRegRes;
  return quick_reg_res_;
}
inline ::ProtoCs::QuickRegRes* Msg::release_quick_reg_res() {
  clear_has_quick_reg_res();
  ::ProtoCs::QuickRegRes* temp = quick_reg_res_;
  quick_reg_res_ = NULL;
  return temp;
}
inline void Msg::set_allocated_quick_reg_res(::ProtoCs::QuickRegRes* quick_reg_res) {
  delete quick_reg_res_;
  quick_reg_res_ = quick_reg_res;
  if (quick_reg_res) {
    set_has_quick_reg_res();
  } else {
    clear_has_quick_reg_res();
  }
}

// optional .ProtoCs.NormalRegReq normal_reg_req = 15;
inline bool Msg::has_normal_reg_req() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Msg::set_has_normal_reg_req() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Msg::clear_has_normal_reg_req() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Msg::clear_normal_reg_req() {
  if (normal_reg_req_ != NULL) normal_reg_req_->::ProtoCs::NormalRegReq::Clear();
  clear_has_normal_reg_req();
}
inline const ::ProtoCs::NormalRegReq& Msg::normal_reg_req() const {
  return normal_reg_req_ != NULL ? *normal_reg_req_ : *default_instance_->normal_reg_req_;
}
inline ::ProtoCs::NormalRegReq* Msg::mutable_normal_reg_req() {
  set_has_normal_reg_req();
  if (normal_reg_req_ == NULL) normal_reg_req_ = new ::ProtoCs::NormalRegReq;
  return normal_reg_req_;
}
inline ::ProtoCs::NormalRegReq* Msg::release_normal_reg_req() {
  clear_has_normal_reg_req();
  ::ProtoCs::NormalRegReq* temp = normal_reg_req_;
  normal_reg_req_ = NULL;
  return temp;
}
inline void Msg::set_allocated_normal_reg_req(::ProtoCs::NormalRegReq* normal_reg_req) {
  delete normal_reg_req_;
  normal_reg_req_ = normal_reg_req;
  if (normal_reg_req) {
    set_has_normal_reg_req();
  } else {
    clear_has_normal_reg_req();
  }
}

// optional .ProtoCs.NormalRegRes normal_reg_res = 16;
inline bool Msg::has_normal_reg_res() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Msg::set_has_normal_reg_res() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Msg::clear_has_normal_reg_res() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Msg::clear_normal_reg_res() {
  if (normal_reg_res_ != NULL) normal_reg_res_->::ProtoCs::NormalRegRes::Clear();
  clear_has_normal_reg_res();
}
inline const ::ProtoCs::NormalRegRes& Msg::normal_reg_res() const {
  return normal_reg_res_ != NULL ? *normal_reg_res_ : *default_instance_->normal_reg_res_;
}
inline ::ProtoCs::NormalRegRes* Msg::mutable_normal_reg_res() {
  set_has_normal_reg_res();
  if (normal_reg_res_ == NULL) normal_reg_res_ = new ::ProtoCs::NormalRegRes;
  return normal_reg_res_;
}
inline ::ProtoCs::NormalRegRes* Msg::release_normal_reg_res() {
  clear_has_normal_reg_res();
  ::ProtoCs::NormalRegRes* temp = normal_reg_res_;
  normal_reg_res_ = NULL;
  return temp;
}
inline void Msg::set_allocated_normal_reg_res(::ProtoCs::NormalRegRes* normal_reg_res) {
  delete normal_reg_res_;
  normal_reg_res_ = normal_reg_res;
  if (normal_reg_res) {
    set_has_normal_reg_res();
  } else {
    clear_has_normal_reg_res();
  }
}

// optional .ProtoCs.BindAccountReq bind_account_req = 17;
inline bool Msg::has_bind_account_req() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Msg::set_has_bind_account_req() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Msg::clear_has_bind_account_req() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Msg::clear_bind_account_req() {
  if (bind_account_req_ != NULL) bind_account_req_->::ProtoCs::BindAccountReq::Clear();
  clear_has_bind_account_req();
}
inline const ::ProtoCs::BindAccountReq& Msg::bind_account_req() const {
  return bind_account_req_ != NULL ? *bind_account_req_ : *default_instance_->bind_account_req_;
}
inline ::ProtoCs::BindAccountReq* Msg::mutable_bind_account_req() {
  set_has_bind_account_req();
  if (bind_account_req_ == NULL) bind_account_req_ = new ::ProtoCs::BindAccountReq;
  return bind_account_req_;
}
inline ::ProtoCs::BindAccountReq* Msg::release_bind_account_req() {
  clear_has_bind_account_req();
  ::ProtoCs::BindAccountReq* temp = bind_account_req_;
  bind_account_req_ = NULL;
  return temp;
}
inline void Msg::set_allocated_bind_account_req(::ProtoCs::BindAccountReq* bind_account_req) {
  delete bind_account_req_;
  bind_account_req_ = bind_account_req;
  if (bind_account_req) {
    set_has_bind_account_req();
  } else {
    clear_has_bind_account_req();
  }
}

// optional .ProtoCs.BindAccountRes bind_account_res = 18;
inline bool Msg::has_bind_account_res() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Msg::set_has_bind_account_res() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Msg::clear_has_bind_account_res() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Msg::clear_bind_account_res() {
  if (bind_account_res_ != NULL) bind_account_res_->::ProtoCs::BindAccountRes::Clear();
  clear_has_bind_account_res();
}
inline const ::ProtoCs::BindAccountRes& Msg::bind_account_res() const {
  return bind_account_res_ != NULL ? *bind_account_res_ : *default_instance_->bind_account_res_;
}
inline ::ProtoCs::BindAccountRes* Msg::mutable_bind_account_res() {
  set_has_bind_account_res();
  if (bind_account_res_ == NULL) bind_account_res_ = new ::ProtoCs::BindAccountRes;
  return bind_account_res_;
}
inline ::ProtoCs::BindAccountRes* Msg::release_bind_account_res() {
  clear_has_bind_account_res();
  ::ProtoCs::BindAccountRes* temp = bind_account_res_;
  bind_account_res_ = NULL;
  return temp;
}
inline void Msg::set_allocated_bind_account_res(::ProtoCs::BindAccountRes* bind_account_res) {
  delete bind_account_res_;
  bind_account_res_ = bind_account_res;
  if (bind_account_res) {
    set_has_bind_account_res();
  } else {
    clear_has_bind_account_res();
  }
}

// optional .ProtoCs.EditPasswordReq edit_password_req = 19;
inline bool Msg::has_edit_password_req() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Msg::set_has_edit_password_req() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Msg::clear_has_edit_password_req() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Msg::clear_edit_password_req() {
  if (edit_password_req_ != NULL) edit_password_req_->::ProtoCs::EditPasswordReq::Clear();
  clear_has_edit_password_req();
}
inline const ::ProtoCs::EditPasswordReq& Msg::edit_password_req() const {
  return edit_password_req_ != NULL ? *edit_password_req_ : *default_instance_->edit_password_req_;
}
inline ::ProtoCs::EditPasswordReq* Msg::mutable_edit_password_req() {
  set_has_edit_password_req();
  if (edit_password_req_ == NULL) edit_password_req_ = new ::ProtoCs::EditPasswordReq;
  return edit_password_req_;
}
inline ::ProtoCs::EditPasswordReq* Msg::release_edit_password_req() {
  clear_has_edit_password_req();
  ::ProtoCs::EditPasswordReq* temp = edit_password_req_;
  edit_password_req_ = NULL;
  return temp;
}
inline void Msg::set_allocated_edit_password_req(::ProtoCs::EditPasswordReq* edit_password_req) {
  delete edit_password_req_;
  edit_password_req_ = edit_password_req;
  if (edit_password_req) {
    set_has_edit_password_req();
  } else {
    clear_has_edit_password_req();
  }
}

// optional .ProtoCs.EditPasswordRes edit_password_res = 20;
inline bool Msg::has_edit_password_res() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Msg::set_has_edit_password_res() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Msg::clear_has_edit_password_res() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Msg::clear_edit_password_res() {
  if (edit_password_res_ != NULL) edit_password_res_->::ProtoCs::EditPasswordRes::Clear();
  clear_has_edit_password_res();
}
inline const ::ProtoCs::EditPasswordRes& Msg::edit_password_res() const {
  return edit_password_res_ != NULL ? *edit_password_res_ : *default_instance_->edit_password_res_;
}
inline ::ProtoCs::EditPasswordRes* Msg::mutable_edit_password_res() {
  set_has_edit_password_res();
  if (edit_password_res_ == NULL) edit_password_res_ = new ::ProtoCs::EditPasswordRes;
  return edit_password_res_;
}
inline ::ProtoCs::EditPasswordRes* Msg::release_edit_password_res() {
  clear_has_edit_password_res();
  ::ProtoCs::EditPasswordRes* temp = edit_password_res_;
  edit_password_res_ = NULL;
  return temp;
}
inline void Msg::set_allocated_edit_password_res(::ProtoCs::EditPasswordRes* edit_password_res) {
  delete edit_password_res_;
  edit_password_res_ = edit_password_res;
  if (edit_password_res) {
    set_has_edit_password_res();
  } else {
    clear_has_edit_password_res();
  }
}

// optional .ProtoCs.RoleInfoNtf role_info_ntf = 6001;
inline bool Msg::has_role_info_ntf() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Msg::set_has_role_info_ntf() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Msg::clear_has_role_info_ntf() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Msg::clear_role_info_ntf() {
  if (role_info_ntf_ != NULL) role_info_ntf_->::ProtoCs::RoleInfoNtf::Clear();
  clear_has_role_info_ntf();
}
inline const ::ProtoCs::RoleInfoNtf& Msg::role_info_ntf() const {
  return role_info_ntf_ != NULL ? *role_info_ntf_ : *default_instance_->role_info_ntf_;
}
inline ::ProtoCs::RoleInfoNtf* Msg::mutable_role_info_ntf() {
  set_has_role_info_ntf();
  if (role_info_ntf_ == NULL) role_info_ntf_ = new ::ProtoCs::RoleInfoNtf;
  return role_info_ntf_;
}
inline ::ProtoCs::RoleInfoNtf* Msg::release_role_info_ntf() {
  clear_has_role_info_ntf();
  ::ProtoCs::RoleInfoNtf* temp = role_info_ntf_;
  role_info_ntf_ = NULL;
  return temp;
}
inline void Msg::set_allocated_role_info_ntf(::ProtoCs::RoleInfoNtf* role_info_ntf) {
  delete role_info_ntf_;
  role_info_ntf_ = role_info_ntf;
  if (role_info_ntf) {
    set_has_role_info_ntf();
  } else {
    clear_has_role_info_ntf();
  }
}

// optional .ProtoCs.CityListNtf city_list_ntf = 6002;
inline bool Msg::has_city_list_ntf() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Msg::set_has_city_list_ntf() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Msg::clear_has_city_list_ntf() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Msg::clear_city_list_ntf() {
  if (city_list_ntf_ != NULL) city_list_ntf_->::ProtoCs::CityListNtf::Clear();
  clear_has_city_list_ntf();
}
inline const ::ProtoCs::CityListNtf& Msg::city_list_ntf() const {
  return city_list_ntf_ != NULL ? *city_list_ntf_ : *default_instance_->city_list_ntf_;
}
inline ::ProtoCs::CityListNtf* Msg::mutable_city_list_ntf() {
  set_has_city_list_ntf();
  if (city_list_ntf_ == NULL) city_list_ntf_ = new ::ProtoCs::CityListNtf;
  return city_list_ntf_;
}
inline ::ProtoCs::CityListNtf* Msg::release_city_list_ntf() {
  clear_has_city_list_ntf();
  ::ProtoCs::CityListNtf* temp = city_list_ntf_;
  city_list_ntf_ = NULL;
  return temp;
}
inline void Msg::set_allocated_city_list_ntf(::ProtoCs::CityListNtf* city_list_ntf) {
  delete city_list_ntf_;
  city_list_ntf_ = city_list_ntf;
  if (city_list_ntf) {
    set_has_city_list_ntf();
  } else {
    clear_has_city_list_ntf();
  }
}

// optional .ProtoCs.ServerKickOffNtf server_kick_off_ntf = 6003;
inline bool Msg::has_server_kick_off_ntf() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Msg::set_has_server_kick_off_ntf() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Msg::clear_has_server_kick_off_ntf() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Msg::clear_server_kick_off_ntf() {
  if (server_kick_off_ntf_ != NULL) server_kick_off_ntf_->::ProtoCs::ServerKickOffNtf::Clear();
  clear_has_server_kick_off_ntf();
}
inline const ::ProtoCs::ServerKickOffNtf& Msg::server_kick_off_ntf() const {
  return server_kick_off_ntf_ != NULL ? *server_kick_off_ntf_ : *default_instance_->server_kick_off_ntf_;
}
inline ::ProtoCs::ServerKickOffNtf* Msg::mutable_server_kick_off_ntf() {
  set_has_server_kick_off_ntf();
  if (server_kick_off_ntf_ == NULL) server_kick_off_ntf_ = new ::ProtoCs::ServerKickOffNtf;
  return server_kick_off_ntf_;
}
inline ::ProtoCs::ServerKickOffNtf* Msg::release_server_kick_off_ntf() {
  clear_has_server_kick_off_ntf();
  ::ProtoCs::ServerKickOffNtf* temp = server_kick_off_ntf_;
  server_kick_off_ntf_ = NULL;
  return temp;
}
inline void Msg::set_allocated_server_kick_off_ntf(::ProtoCs::ServerKickOffNtf* server_kick_off_ntf) {
  delete server_kick_off_ntf_;
  server_kick_off_ntf_ = server_kick_off_ntf;
  if (server_kick_off_ntf) {
    set_has_server_kick_off_ntf();
  } else {
    clear_has_server_kick_off_ntf();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoCs

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cs_5fmsg_2eproto__INCLUDED
